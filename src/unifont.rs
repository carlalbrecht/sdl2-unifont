/// TODO new description

use std::collections::HashMap;
use std::io::{BufRead, BufReader, Cursor, Error, ErrorKind};

use lzma::LzmaError;
use lzma::LzmaReader;


// NOTE: The following files are generated by build.rs

#[cfg(feature = "plane-0")]
/// Contains the raw file contents of the Unifont plane 0 font
const PLANE_0_RAW: &'static [u8] =
    include_bytes!("../data/unifont-11.0.02.hex.xz");

#[cfg(feature = "plane-1")]
/// Contains the raw file contents of the Unifont plane 1 font
const PLANE_1_RAW: &'static [u8] =
    include_bytes!("../data/unifont_upper-11.0.02.hex.xz");


/// Set to true after the first time a reference to the font hashmap has been
/// requested.
static IS_INITIALISED: bool = false;


/// Contains parsed character definitions. A hashmap is utilised for fast
/// look-ups, since there are often gaps between defined characters in the
/// Unifont files.
static UNIFONT: HashMap<u32, FontChar> = HashMap::new();


/// Describes a single character in the font.
pub struct FontChar {
    /// Width, either 8px (half-width) or 16px (full-width)
    pub width: u8,
    /// Array of lines of the character's form. MSB is unused for half-width
    /// characters
    pub bitmap: [u16; 16]
}


/// Decompresses a supplied embedded font file, before parsing the decompressed
/// result using `initialise_from_str`.
fn initialise_generic(font: &[u8]) -> Result<(), LzmaError> {
    // Read decompressed embedded font line-by-line
    let mut cur = Cursor::new(font);
    let decomp = LzmaReader::new_decompressor(cur)?;
    let reader = BufReader::new(decomp);
    let lines = reader.lines();

    // Returned as the Result value if the font file is malformed
    let corrupt_file_err =
        Err(LzmaError::Io(
            Error::new(ErrorKind::InvalidData, "font file malformed")));

    for l in lines {
        let line = l.unwrap();
        let mut split = line.split(":");

        // Parse code point of current character
        let codepoint = match split.next() {
            Some(cp) => match u32::from_str_radix(cp, 16) {
                Ok(cp_num) => cp_num,
                Err(_) => return corrupt_file_err
            },

            None => return corrupt_file_err
        };

        // Retrieve bitmap string
        let bitmap = match split.next() {
            Some(bmp) => bmp,
            None => return corrupt_file_err
        };

        // Determine if current character is half or full-width
        let char_count = bitmap.chars().count();
        let char_width = char_count / 4;

        if char_width != 8 && char_width != 16 {
            return corrupt_file_err;
        }

        // Number of chars per pixel row
        let row_width = char_width / 4;

        // Create and load binary bitmap array
        let mut bitmap_arr: [u16; 16] = [0; 16];
        let mut bitmap_i = 0;

        for i in 0..char_count / row_width {
            let line = &bitmap[i..i + row_width];

            // Convert hex line bit pattern to binary
            bitmap_arr[bitmap_i] = match u16::from_str_radix(line, 16) {
                Ok(bit_line) => bit_line,
                Err(_) => return corrupt_file_err
            };

            bitmap_i += 1;
        }

        // We have all the information we need; insert the completed character
        // into our global hashmap.
        UNIFONT.insert(codepoint, FontChar {
            width: char_width as u8,
            bitmap: bitmap_arr
        });
    }

    Ok(())
}


/// Called the first time that a reference to the `UNIFONT` hashmap is requested
/// in order to decompress and parse the embedded, xzipped .hex contents
fn initialise_unifont() -> Result<(), LzmaError> {
    #[cfg(feature = "plane-0")]
    initialise_generic(PLANE_0_RAW)?;

    #[cfg(feature = "plane-1")]
    initialise_generic(PLANE_1_RAW)?;

    // Prevent second initialisation
    IS_INITIALISED = true;

    Ok(())
}


/// Returns a reference to the parsed Unifont hashmap structure. Initialises
/// said structure if it hasn't already been.
pub fn get_unifont() -> Result<&'static HashMap<u32, FontChar>, LzmaError> {
    if !IS_INITIALISED {
        initialise_unifont();
    }

    Ok(&UNIFONT)
}
